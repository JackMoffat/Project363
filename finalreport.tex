% Created 2019-12-21 Sat 17:51
% Intended LaTeX compiler: pdflatex
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[english]{babel}
\bibliographystyle{plain}
\author{Jackm}
\date{\today}
\title{The n-back Test}
\hypersetup{
 pdfauthor={Jackm},
 pdftitle={The n-back Test},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.0.50 (Org mode 9.1.9)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{Introduction}
\label{sec:org8b8b6b2}

In 1958, Wayne Kirchner invented the n-back test \cite{COULACOGLOU201791}. The n-back test is a visuospatial task that has been shown to improve working memory and attentional skills \cite{COLOM2013712}. The basic mechanisms of the test involve the presentation of continuous stimulis in terms of letters or pictures â€“ for every stimulus presented, the participant has to indicate whether it matches a stimulus that was presented n stimuli ago \cite{Kane}. There are different types of n-back tests known as loads: 3-back test, 2-back test and 1-back test \cite{Forns}.

\section{Hypothesis}
\label{sec:orga6f14ff}

Our hypothesis was that participants would have a more challenging time remembering things initially which would be reflected in a longer reaction time to congruent stimulis in the 2-back test compared to the reaction time of a 1-back test. However, as n-back tests are shown to improve working and short term memory \cite{LEONDOMINGUEZ2015167}, we expect participants to get better at remembering, reflected in shorter reaction times in responding to congruent stimulis.

\section{Materials/Methods}
\label{sec:org394e780}

\subsection{Inline usage}
\label{sec:org6eaf17d}

\section{Results}
\label{sec:org5ec0dbd}
\subsection{Information from Pelegrina et. Al (2015)}
\label{sec:org0acac0a}

\subsubsection{R code}
\label{sec:org5e63440}
Our results are not particularly well suited for demonstrating the capabilities of org-mode. 
The following block pulls in normative data from \cite{NormativeData} and store it in the \textbf{tables} session
\begin{verbatim}
    ## install.packages('dplyr')
    ## install.packages('ggplot2')
    ## install.packages('tidyr')
    library('dplyr')
    library('tidyr')

    d <- read.csv("./dataFromPaper/csvfpsyg-06-01544.csv")
    tbl_df(d)
    oneback<-slice(d,11:12)
    twoback<-slice(d,18:19)
    threeback<-slice(d,25:26)

    mean_sd <- tbl_df(bind_rows(oneback,twoback,threeback))
    rename(mean_sd,"Var"=X)
    mMeanSD <- tbl_df(select(mean_sd,X:X.8,-X.2))
    fMeanSD <- tbl_df(select(mean_sd,X:X.1,Girls:X.14))
mMeanSD

\end{verbatim}

Org-mode block as a function to rename column names prior to plotting
\begin{verbatim}
newColNames <- c("n-back","M_or_SD","7","8","9","10","11","12","13")
names(df) <- newColNames
df
\end{verbatim}










\subsubsection{Python Code}
\label{sec:org60f279b}
This code adds headers back into the data
\begin{verbatim}
import numpy as np
import pandas as pd
dArr = np.array(data)
headers = ["n-back","statistic"]
[headers.append(i) for i in range(7,14)]
headers = np.array(headers)
dArr = np.vstack((headers,dArr))

dArr
\end{verbatim}

\begin{verbatim}

import matplotlib.pyplot as plt
data=np.array(data)


\end{verbatim}



\subsection{Table}
\label{sec:orgf9661ed}
\begin{verbatim}

    data=np.array(data)
    tuples=[]
    for idx, val in enumerate(data[:,0]):
        if val != "":
            tuples.append((data[idx,0],data[idx,1]))
        else:
            tuples.append((data[idx-1,0],data[idx,1]))
    del tuples[0]


    pandf = pd.DataFrame(
        data=data[1:,2:],
        columns=data[0,:],
        index=pd.MultiIndex.from_tuples(
            tuples,
            names=[data[0,0],data[0,1]])

        )
pandf

\end{verbatim}

\subsection{Simple summary statistics}
\label{sec:orge7d929c}
\begin{verbatim}
data=pd.Dataframe(pandarray)
data
\end{verbatim}

\subsection{2 plots}
\label{sec:orgfb8513c}



\section{Discussion}
\label{sec:org5544c14}

Our experiment was done with the hypothesis that the reaction time to stimuli in a 1-Back test would be shorter than the reaction time to stimuli in a 2-Back test. This was based off of the fact that there is one extra letter presented between letter stimuli to remember during 2-Back tests. This test is a working memory task, but it could also potentially be used to test the recency effect, which has been shown to be eliminated when another stimulus is presented. \cite cohen1989effects
\section{Bibliography}
\label{sec:org67a3cb2}

\bibliography{references}

\section{Appendix}
\label{sec:org4bdb128}
\subsection{Python Code for n-back test}
\label{sec:orgebf3c91}
\begin{verbatim}
from psychopy import visual, event, core
import pandas as pd
import random
import time as systime

#########
# setup #
#############################

#############
# Make lists / define functions #
#############


def makeMatches(in_list, trials=5,
                threshold=0, n_back=2,
                keep_list_stats=True, verbose=False):
    '''Creates the matches in a given list.if a random number is greater than threshold,
    then match the letters at positions [idx] and [idx-n_back]
    in_list: list of letters, strings, etc
    trials: how many trials to run
    threshold: type(float) in range(0,1)ld
    keep_stats: Bool: will output a list with information on
    the matches (position, character) and their frequency
    verbose: Bool: prints information about the lists for immediate viewing
    '''

    # done this way to avoid changing original list, confirm necessity?
    out_list = [i for i in in_list]
    list_stats = []  # list holding the character and positions it was matched at
    num_matches = 0
    for idx, char in enumerate(in_list):
        if idx > 1:
            if (random.random() > threshold):
                out_list[idx] = in_list[idx-n_back]
                list_stats.append([(idx, idx-2), char]
                                  ) if keep_list_stats else None
                num_matches += 1

                real_match_rate = num_matches / (len(in_list) - 2)
                # show _stats or not
                if verbose:  # switch this out of a print statement for final thing so it doesnt show up
                    print(
                        f"{num_matches} of {len(in_list)-2} possible matches: {real_match_rate* 100} %")
                    print(f"in_list\n", in_list, "\nmatched list\n", out_list)
                else:
                    pass

                if keep_list_stats:
                    list_stats.insert(0, [(num_matches), "number of matches"])
                    list_stats.insert(0, [(real_match_rate), "actual match rate"])
        return(out_list, list_stats)
    else:
        return(out_list)


#####################
# create trial list #
#####################

n_trials = 15
# need to think of this inverted with how the code is currently written
match_frequency_threshold = 0.5
alphabet = [i for i in "ABCDEFGHIJKLMNOPQRSTUVWXYZ"]
initial_letters = [random.choice(alphabet) for i in range(n_trials)]

trial_list = makeMatches(initial_letters, trials=n_trials,
                         threshold=match_frequency_threshold, keep_list_stats=False)
ptt = 1.2
# ptt is the amount of time between trials, stands for "per time trial"

######################
# Window setup below #
######################
mywin = visual.Window(fullscr=True, screen=0, allowGUI=False, allowStencil=False,
                      monitor='testMonitor', color=[0, 0, 0], colorSpace='rgb')

clock = core.Clock()  # this is a clock

press_times = []  # List records the data


##############################

intro = True

if intro:
    # TODO  Find out how to display the last sentence in text_string
    text_string = f"This is an N-Back task.  This task is a test of working memory.  You will be presented with a random series of letters, one by one.  For this task, you will press the spacebar if you see a letter that was repeated two letters back.  For example, if you see a sequence such as A, D, A, then you will have to press the spacebar.  You will be given a sequence of {n_trials} letters.  "
    textList = text_string.split("  ")
    for msg in textList:
        displayMsg = visual.TextStim(
            mywin, text=msg, pos=(0.5, 0))
        mywin.flip()
        displayMsg.draw()
        core.wait(3.5)

    countdownMessage = visual.TextStim(
        mywin, text='The task will begin after this countdown.', pos=(0.5, 0))
    countdownMessage.autoDraw = True
    mywin.flip()
    core.wait(3.5)
    countdownMessage.text = ' '
    mywin.flip()
    core.wait(0.5)



countdownString = "5,4,3,2,1"
countdown = countdownString.split(',')
# ct is the countdown timer

for num in countdown:
    txtDisplay = visual.TextStim(
        mywin, text = num , alignHoriz='left', alignVert='center', pos=(0, 0))
    mywin.flip()
    txtDisplay.draw()
    core.wait(1.0)


###################
# display letters #
###################

trialTime = core.Clock()

for idx, char in enumerate(trial_list):

    trialLength = core.CountdownTimer()
    keys = event.getKeys(keyList=["space"], timeStamped = trialLength)
    txtDisplay.text = char
    mywin.flip()
    txtDisplay.draw()
    print(keys, trialLength.getTime(), txtDisplay.text)
    press_times.append([keys, trialLength.getTime(), txtDisplay.text])
    core.wait(ptt)
    txtDisplay.text = "+"
    mywin.flip()
    txtDisplay.draw()
    core.wait(ptt)
    trialLength.reset()
    # currently appending in tuple form list_stats = []  # list holding the character and positions it was matched at

endMessage = visual.TextStim(
    mywin, text = ' ', pos=(0.5, 0))
endMessage.autoDraw=True
mywin.flip()
core.wait(1.5)
endMessage.text = 'You have completed the N-Back task. Thank you!'
mywin.flip()
core.wait(3.0)

print(press_times)

ts = systime.localtime()
timestamp = str(systime.strftime("Y%yM%mD%dH%HM%MS%S",ts))
datafile = open(f"datafile_{timestamp}.txt", "w+")

################
# writing file #
################
for line in press_times:
    datafile.write(str(line))
    datafile.write("\n")
    datafile.close()

# #not sure needed
# for line in n_list:
#     datafile.write(line,)
#     datafile.write("\n")

# for line in stats:
#     datafile.write(line)
#     datafile.write("\n")

\end{verbatim}
\subsection{Data from Our Python Code}
\label{sec:org65fd546}
\end{document}
